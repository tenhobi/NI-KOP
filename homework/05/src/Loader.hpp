#ifndef INC_05_LOADER_HPP
#define INC_05_LOADER_HPP

#include <string>
#include <utility>
#include <filesystem>

#include "SAT/Formula.hpp"

class Loader {
private:
    std::string fileName;
    std::string optFileName;

public:
    explicit Loader(std::string fileName, std::string optFileName) : fileName(std::move(fileName)),
                                                                     optFileName(std::move(optFileName)) {}

public:

//    c This Formular is generated by mcnf
//    c
//    c    horn? no
//    c    forced? no
//    c    mixed sat? no
//    c    clause length = 3
//    c
//    p mwcnf 20 79
//    c SAT instance uf20-78/uf20-01.cnf
//    w 491 260 355 449 1 384 282 239 392 651 358 562 100 455 16 51 683 50 332 409 0
//    c range 100 1500 straight
//    4 -18 19 0
//    3 18 -5 0

    Formula loadFormula() {
        std::ifstream file(this->fileName);
        if (!file.is_open()) {
            std::cout << "Error: Couldn't open the input file." << std::endl;
            exit(2);
        }


        bool shouldBreak = false;
        std::string id;
        int variablesCount;
        int clausesCount;
        std::vector<int> variablesWeights;
        bool flagLineWithId = false;
        std::string optFileId;

        // Load id, variablesCount, clausesCount, weights vector
        std::string line;
        int lastPos = file.tellg();
        while (std::getline(file, line)) {
            std::istringstream lineStream(line);
            char lineType;
            lineStream >> std::noskipws >> lineType; // Don't forget to turn on skipping.

            switch (lineType) {
                case ' ':
                    shouldBreak = true;
                    file.seekg(lastPos);
                    break;
                case 'c':
                    if (flagLineWithId) {
                        flagLineWithId = false;
                        std::string value;
                        std::getline(lineStream, value, '/');
                        std::getline(lineStream, value, '/');
                        optFileId = value.substr(0, value.size() - 4);;
                    }
                    break;
                case 'p':
                    lineStream >> std::skipws >> id >> variablesCount >> clausesCount;
                    flagLineWithId = true;
                    break;
                case 'w':
                    lineStream >> std::skipws;
                    int value;
                    for (int i = 0; i < variablesCount; i++) {
                        lineStream >> value;
                        variablesWeights.push_back(value);
                    }
                    break;
                default:
                    shouldBreak = true;
                    break;
            }

            if (shouldBreak) break;

            lastPos = file.tellg();
        }

        std::vector<Clause> clauses;
        // Load clauses
        for (int i = 0; i < clausesCount - 1; i++) {
            int one, two, three, nothing;
            file >> one >> two >> three >> nothing;
            std::vector<int> tmp = {one, two, three};
            clauses.emplace_back(tmp);
        }

        file.close();

        // Optimal fitness discovery.
        long fitness = -1;

        std::ifstream optFile(this->optFileName);
        if (optFile.is_open()) {
            while (std::getline(optFile, line)) {
                std::istringstream lineStream(line);
                std::string optId;
                lineStream >> optId;

                if (optId == optFileId) {
                    lineStream >> fitness;
                    break;
                }
            }
        }
        optFile.close();

        if (fitness == -1) {
            std::cout << "ERROR, no opt file record" << std::endl;
        }

        return Formula(id, fitness, variablesWeights, clauses);
    }
};


#endif //INC_05_LOADER_HPP
